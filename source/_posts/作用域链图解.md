---
title: 作用域链图解
date: 2020-10-13 11:36:33
tags: 作用域链
categories:
  - javascript
---

## __作用域链图解__

![作用域链](/images/zuoyongyulian.jpg)

## __作用域__

js采用词法作用域
在ES6之前，js中有三种作用域
> 1. 全局作用域
> 2. 函数作用域
> 3. eval作用域（严格模式下才有）

以上作用域内声明的变量或方法只有当前作用域内有效。

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

## __全局作用域__

不在任何函数内声明的变量称作全局变量，它在js程序中的任何地方都是可见的。
代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。

## __函数作用域__

在函数内声明的变量具有函数作用域，并且只在函数内可见。
在固定的代码片段才能被访问

## __块级作用域__

而ES6新增了一个 块级作用域

块级作用域可以简单理解为是: 包在大括号{}里面的内容, 它可以自成一个作用域, 但ES5中也有大括号, 可ES5中并没有块级作用域, 这时该怎样判断 {} 是否具有块级作用域的特点?

这时就得用到 let 和 const
 
因此, 可以将块级作用域理解为: 使用let和const声明的变量, 只在当前大阔号内生效, 由此构建出了 块级作用域 这么个东西.
这里的 "大括号内" 主要指的下面几种情况:

```javascript
  // 条件语句 if  else   else if
  if () {}

  // switch语句
  switch () {}

  // for / while循环语句
  for () {}
  while () {}

  // try...catch语句
  try () catch (err) {}

  // 单大括号
  {}
```

通过var定义的变量可以跨块作用域访问到（就相当于块级作用域中的var是定义到上级作用域中的（函数作用域或者全局作用域）），但是不能跨函数作用域访问到

通过下面的代码也可知：if语句和for语句属于块作用域，不属于函数作用域。

```javascript
  {
    var a = 1;
    console.log(a); // 1
  }
  console.log(a); // 1
  // 可见，通过var定义的变量可以跨块作用域访问到。

  (function A() {
  var b = 2;
  console.log(b); // 2
  })();
  // console.log(b); // 报错，
  // 可见，通过var定义的变量不能跨函数作用域访问到

  if(true) {
    var c = 3;
  }
  console.log(c); // 3
  for(var i = 0; i < 4; i++) {
    var d = 5;
  };
  console.log(i); // 4   (循环结束i已经是4，所以此处i为4)
  console.log(d); // 5

  // if语句和for语句中用var定义的变量可以在外面访问到，
  // 可见，if语句和for语句属于块作用域，不属于函数作用域。
```

var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。可声明提升

let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不可声明提升

const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。不可声明提升

```javascript
  // 块作用域
  {
    var a = 1;
    let b = 2;
    const c = 3;
    // c = 4; // 报错
    var aa;
    let bb;
    // const cc; // 报错
    console.log(a); // 1
    console.log(b); // 2
    console.log(c); // 3
    console.log(aa); // undefined
    console.log(bb); // undefined
  }
  console.log(a); // 1
  // console.log(b); // 报错
  // console.log(c); // 报错
  // 函数作用域
  (function A() {
      var d = 5;
      let e = 6;
      const f = 7;
      console.log(d); // 5
      console.log(e); // 6  (在同一个{ }中,也属于同一个块，可以正常访问到)
      console.log(f); // 7  (在同一个{ }中,也属于同一个块，可以正常访问到)
  })();
  // console.log(d); // 报错
  // console.log(e); // 报错
  // console.log(f); // 报错
```

## __自由变量__

在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下

```javascript
  var x = 10;

  function fn() {
    var b = 20;
    console.log(b + x); // x变量在这里就是一个自由变量
  }
```

## __作用域链__

![作用域链](/images/zyyl.png)

作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。如上，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。

变量取值：<b class="c42b983">到创建 这个变量 的函数的作用域中取值，切记是创建的作用域中取值，而不是调用的作用域中取值！其实这就是所谓的“静态作用域”。</b>

但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

所以下面的结果是10

```javascript
  var x = 10;

  function fn(){
      console.log(x);
  }

  function show(f){
      var x = 20;
      (function(){
        f();    // 10 而不是20
      })()  
  }

  show(fn); // 10
```

对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？

> 要到创建fn函数的那个作用域中取, 无论fn函数将在哪里调用。

上面描述的只是跨一步作用域去寻找。

如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。
这个一步一步“跨”的路线，我们称之为——作用域链。

![作用域链](/images/zyylx.png)

以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。


